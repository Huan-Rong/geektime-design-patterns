# 9 接口 VS 抽象类

在面向对象编程中，抽象类和接口是 4 大特性、以及很多设计模式、设计思想、设计原则的实现基础。比如，接口可以实现抽象特性、多态特性、基于接口而非实现的设计原则，抽象类可以实现模板设计模式。

Python 这样的动态编程语言，既不支持接口，也不支持抽象类。C++ 只支持抽象类，不支持接口。也就是说，并非所有的 OOPL 都支持这两个语法概念，但是我们可以通过模拟的方式来实现这两个语法概念。

## 从语法的角度
### 抽象类

* 不允许实例化抽象类
* 抽象类可以包含属性和方法
  * 方法既可以包含代码实现，也可以是抽象方法
* 子类继承抽象类，必须实现抽象类中所有的抽象方法

### 接口

* 接口不能包含属性
* 接口只能声明方法，方法不能包含代码实现
* 类实现接口时，必须实现接口中所有声明的方法

## 从设计的角度

* 抽象类表达 `is-a`；抽象类是一种自下而上的设计思路。
* 接口表达 `has-a`，表示一组行为特性；接口是一种自上而下的设计思路。

## 从存在意义的角度
### 抽象类

* 代码复用：抽象类不能被实例化，只能被子类继承；也就是说，抽象类天生就是为了代码复用的。
* 实现多态：一般的继承也能够实现代码复用，但使用抽象类，我们还可以进一步实现多态；并且多态不仅有助于提高代码的可扩展性、可读性等，具体查看下面代码。

```java
/**
 * 使用非抽象类作为父类的情况分析。
 *
 * 父类可以被实例化，容易导致父类被误用。
 */
public class Logger {
  // 空方法会导致可读性变差
  public void log(Level level, String mesage) {
    // do nothing...  
  }
}

public class FileLogger extends Logger {
  // 子类很容易忘记重写父类方法
  @Override
  public void log(Level level, String mesage) {
    if (!isLoggable()) return;
      fileWriter.write(...);
  }
}

public class MessageQueueLogger extends Logger {
  @Override
  public void log(Level level, String mesage) {
    if (!isLoggable()) return;
    msgQueueClient.send(...);
  }
}
```

### 接口类

接口和抽象类都可以实现多态，但不同的是，抽象类侧重代码复用、继而实现多态；接口更侧重于解耦，即实现了约定和实现的分离。

## 总结

1. 接口仅对方法抽象，是一种 has-a 关系，表达了一组行为特性，解决了约定与实现分离；抽象类对属性和方法抽象，是一种 is-a 关系，解决了代码复用的问题；
2. 接口和抽象类都可以实现多态特性，进而提升代码的可扩展性；不同的是，接口侧重于解耦，抽象类侧重于代码复用。

